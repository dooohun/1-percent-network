# 2장 서버에 접속한다.

인터넷을 통해 웹 페이지를 불러오거나, 이메일을 주고받거나, 온라인 게임을 즐기는 등 다양한 온라인 활동에서 서버에 접속하는 일은 빈번하게 일어난다. 클라이언트가 서버에 접속하는 과정에 대해 자세히 알아보도록 하자.

데이터 송/수신 단계는 다음과 같다.

  1.	소켓 작성
  2.	접속 단계
  3.	데이터 송/수신 단계
  4.	연결 끊기 단계

프로토콜 스택의 내부 구성  

OS 영역에는 프로토콜 스택이 있는데, TCP와 UDP 그리고 둘의 아래 계층에는 IP가 존재한다. 네트워크 애플리케이션은 데이터 송/수신을 위해 TCP 혹은 UDP를 사용한다.  
브라우저나 메일 등의 일반적인 애플리케이션이 데이터를 송/수신할 경우에는 TCP를 사용하고, DNS 서버에 대한 조회 등에서 짧은 제어용 데이터를 송/수신할 경우에는 UDP를 사용한다.  
IP 프로토콜은 패킷 송수신 동작을 제어하는 역할을 한다. 패킷이란 송/수신 데이터의 조각이며, 네트워크 통신에서 데이터는 패킷이라는 조각으로 나뉘어 보내진다.  
IP 프로토콜은 패킷을 통신 상대까지 운반하는 것이 주 역할이다. IP 프로토콜은 또한 ICMP(Internet Control Message Protocol)과 ARP(Address Resolution Protocol)라는 프로토콜을 포함하는데 각각 ICMP는 패킷 운반 시 발생하는 오류를 통지하거나, 제어용 메시지를 통지하는 역할을 한다.  

![image1](https://velog.velcdn.com/images/ehgns0305/post/c6b23837-0718-4c39-8fb0-2a32ecfd4ec8/image.png)

## 소켓 작성
Socket을 호출하여 소켓을 만드는 것을 의뢰하면 프로토콜 스택은 의뢰에 따라 한 개의 소켓을 만든다. 프로토콜 스택이 최초로 하는 일은 소켓 한 개 분량의 메모리 영역을 확보하는 것이다.  
메모리 영역 확보한다는 것은 제어 정보를 담을 그릇을 준비하는 것과 같다.
소켓이 만들어지면 소켓을 나타내는 디스크립터를 애플리케이션에 알려준다.

접속 단계  
어플리케이션은 소켓 생성 후 connect 메소드를 호출하여 접속 동작을 시작한다. 조금 더 구체적으로 설명하자면, 데이터를 주고받고자 하는 대상과 필요한 정보를 주고받아서 기록하고 데이터 송수신이 가능한 상태로 만드는 것이다. 

Connect(디스크립터, 서버측의 IP 주소와 포트번호)

제어 정보는 크게 두 가지가 존재한다.  
클라이언트와 서버가 서로 연락을 절충하기 위해 주고받는 제어 정보와 소켓에 기록하여 프로토콜 스택의 동작을 제어하기 위한 정보가 있다.
제어 정보를 패킷의 맨 앞부분에 배치하는 곳부터 헤더라고 부른다.

![image2](https://velog.velcdn.com/images/ehgns0305/post/0743e722-c619-40ab-8a6e-6a002684729b/image.png)  

TCP 헤더의 포멧 중 컨트롤 비트를 주목할 필요가 있다. 컨트롤 비트는 TCP 통신에서 다양한 제어 기능을 수행하기 위한 정보를 담고 있는 필드이다. 이 컨트롤 비트들은 TCP 세그먼트의 동작과 제어를 조정하는 데 사용된다.  
TCP는 3-way handshake를 통해 클라이언트와 서버간의 신뢰성 있는 연결에 큰 역할을 한다.  

![image3](https://velog.velcdn.com/images/ehgns0305/post/32479359-baf4-4061-9e6a-37ad4f04a3c7/image.png)

**송신자(Client)가 서버에게 연결 요청**  
클라이언트가 서버에게 TCP 연결을 요청하기 위해 SYN(동기화) 비트를 설정한 TCP 패킷을 보낸다. 이 패킷에는 클라이언트의 초기화 시퀀스 번호(ISN)가 포함된다. 이것은 클라이언트가 처음 데이터를 보낼 때 사용될 시퀀스 번호이다. 

**수신자(서버)가 연결 요청을 수락하고 응답**  
서버가 클라이언트의 연결 요청을 받으면 SYN 비트를 설정하고, 또한 자체적인 ISN을 설정하여 ACK(확인응답) 비트를 설정한 TCP 패킷을 클라이언트로 다시 보낸다. 이 패킷은 클라이언트로부터 받은 초기화 시퀀스 번호에 1을 더한 값을 가지게 된다.

**송신자(클라이언트)가 응답을 확인**   
클라이언트는 서버로부터 받은 응답 패킷을 받으면, 이제 연결이 수립되었음을 확인하기 위해 ACK 비트를 설정한 패킷을 서버로 다시 보낸다. 이때, 이전에 수신한 서버의 ISN 값에 1을 더한 값을 ACK 번호로 설정한다.

## 데이터 송/수신 단계

connect에서 애플리케이션에 제어가 되돌아오면 데이터 송/수신 동작에 들어가게 된다. Write를 호출하여 송신 데이터를 프로토콜 스택에 건네주는 곳부터 시작된다.

1.	프로토콜 스택에 HTTP 리퀘스트 메시지를 넘긴다  
송신자가 HTTP 리퀘스트 메시지를 생성하고 이를 TCP 패킷에 담아 송신합니다. 이때, 패킷에는 목적지 주소, 포트 번호, 시퀀스 번호 등이 포함된다.

2. 데이터가 클 때는 분할하여 보낸다:
 큰 데이터를 한 번에 보내기 어려울 때, TCP는 데이터를 여러 개의 작은 패킷으로 분할하여 전송한다. 이렇게 분할된 패킷들은 수신자에서 재조립된다.

3.	ACK 번호를 사용하여 패킷이 도착했는지 확인한다:
•	수신자는 받은 패킷을 확인하고, 해당 패킷의 시퀀스 번호를 포함한 ACK(확인응답)을 송신자에게 전송한다. 이를 통해 송신자는 어떤 패킷이 정상적으로 도착했는지를 알 수 있다.

4.	패킷 평균 왕복 시간으로 ACK 번호의 대기 시간을 조정한다:
•	패킷의 왕복 시간(라운드 트립 타임)을 측정하여 네트워크의 현재 상황을 파악하고,  ACK 번호를 기다리는 대기 시간을 조절한다. 이를 통해 더 효율적인 통신이 가능해진다.

5.	윈도우 제어 방식으로 효율적으로 ACK 번호를 관리한다:
•	TCP는 윈도우 제어 방식을 사용하여 여러 개의 패킷을 동시에 전송하고, 수신자는 윈도우 크기를 조절하여 송신자에게 받을 수 있는 패킷의 개수를 알려준다. 이를 통해 불필요한 대기 시간을 최소화하고 효율적으로 패킷을 전송한다.

6.	ACK 번호와 윈도우를 합승한다:
•	ACK 번호와 윈도우 크기 정보를 함께 사용하여 송신자와 수신자는 데이터의 흐름을 조절하며 효율적으로 통신한다.

7.	HTTP 응답 메시지를 수신한다:
•	수신자가 HTTP 리퀘스트를 처리하고 응답 메시지를 생성하면, 해당 응답 메시지를 TCP 패킷에 담아 송신자에게 전송한다. 송신자는 이를 수신하여 HTTP 응답을 처리한다.

## 서버에서 연결을 끊어 소켓을 없앤다.

1.	데이터 보내기를 완료했을 때 연결을 끊는다  
데이터를 송신하고자 하는 쪽에서 모든 데이터를 성공적으로 보냈을 때, 연결을 종료하기 위해 송신자는 FIN(Finish) 패킷을 전송한다. 이는 데이터 송신이 완료되었음을 나타내며, 수신자는 FIN 패킷을 받으면 ACK(확인응답)을 반환하고 데이터 수신이 완료되었음을 인식한다. 그 후, 수신자 역시 FIN 패킷을 전송하여 송신자에게 연결 종료를 요청한다. 이러한 과정을 4-way handshake라고 한다.

    ![](https://velog.velcdn.com/images/ehgns0305/post/beb7393f-2c1d-4978-8456-530e6ec7a26a/image.png)

2.	소켓을 없앤다  
연결 종료가 완료되면, 소켓을 말소하고 연결된 자원 및 메모리를 해제한다. 소켓을 없애는 작업은 송신자와 수신자 양쪽에서 이루어진다. 이후에는 해당 소켓을 사용할 수 없게 된다.

3.	데이터 송/수신 동작을 정리한다:
데이터 송/수신 동작이 더 이상 필요하지 않을 때, 해당 동작을 정리하고 관련된 자원을 해제한다. 이는 연결 종료 후의 추가 동작에 대한 정리 작업을 의미한다. 이 단계에서는 해당 연결과 관련된 모든 정보와 자원을 정리하고 초기화한다.

